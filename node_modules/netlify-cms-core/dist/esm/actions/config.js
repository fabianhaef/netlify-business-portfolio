"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeConfig = normalizeConfig;
exports.applyDefaults = applyDefaults;
exports.parseConfig = parseConfig;
exports.configLoaded = configLoaded;
exports.configLoading = configLoading;
exports.configFailed = configFailed;
exports.detectProxyServer = detectProxyServer;
exports.handleLocalBackend = handleLocalBackend;
exports.loadConfig = loadConfig;
exports.CONFIG_FAILURE = exports.CONFIG_SUCCESS = exports.CONFIG_REQUEST = void 0;

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _trimStart2 = _interopRequireDefault(require("lodash/trimStart"));

var _yaml = _interopRequireDefault(require("yaml"));

var _immutable = require("immutable");

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _publishModes = require("../constants/publishModes");

var _configSchema = require("../constants/configSchema");

var _collections = require("../reducers/collections");

var _integrations = require("../reducers/integrations");

var _backend = require("../backend");

var _i18n2 = require("../lib/i18n");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const CONFIG_REQUEST = 'CONFIG_REQUEST';
exports.CONFIG_REQUEST = CONFIG_REQUEST;
const CONFIG_SUCCESS = 'CONFIG_SUCCESS';
exports.CONFIG_SUCCESS = CONFIG_SUCCESS;
const CONFIG_FAILURE = 'CONFIG_FAILURE';
exports.CONFIG_FAILURE = CONFIG_FAILURE;

function traverseFieldsJS(fields, updater) {
  return fields.map(field => {
    let newField = updater(field);

    if (newField.fields) {
      newField = _objectSpread(_objectSpread({}, newField), {}, {
        fields: traverseFieldsJS(newField.fields, updater)
      });
    } else if (newField.field) {
      newField = _objectSpread(_objectSpread({}, newField), {}, {
        field: traverseFieldsJS([newField.field], updater)[0]
      });
    } else if (newField.types) {
      newField = _objectSpread(_objectSpread({}, newField), {}, {
        types: traverseFieldsJS(newField.types, updater)
      });
    }

    return newField;
  });
}

function getConfigUrl() {
  const validTypes = {
    'text/yaml': 'yaml',
    'application/x-yaml': 'yaml'
  };
  const configLinkEl = document.querySelector('link[rel="cms-config-url"]');
  const isValidLink = configLinkEl && validTypes[configLinkEl.type] && (0, _get2.default)(configLinkEl, 'href');

  if (isValidLink) {
    const link = (0, _get2.default)(configLinkEl, 'href');
    console.log(`Using config file path: "${link}"`);
    return link;
  }

  return 'config.yml';
}

function setDefaultPublicFolder(map) {
  if (map.has('media_folder') && !map.has('public_folder')) {
    map = map.set('public_folder', map.get('media_folder'));
  }

  return map;
} // Mapping between existing camelCase and its snake_case counterpart


const WIDGET_KEY_MAP = {
  dateFormat: 'date_format',
  timeFormat: 'time_format',
  pickerUtc: 'picker_utc',
  editorComponents: 'editor_components',
  valueType: 'value_type',
  valueField: 'value_field',
  searchFields: 'search_fields',
  displayFields: 'display_fields',
  optionsLength: 'options_length'
};

function setSnakeCaseConfig(field) {
  const deprecatedKeys = Object.keys(WIDGET_KEY_MAP).filter(camel => camel in field);
  const snakeValues = deprecatedKeys.map(camel => {
    const snake = WIDGET_KEY_MAP[camel];
    console.warn(`Field ${field.name} is using a deprecated configuration '${camel}'. Please use '${snake}'`);
    return {
      [snake]: field[camel]
    };
  });
  return Object.assign({}, field, ...snakeValues);
}

function setI18nField(field) {
  if (field.get(_i18n2.I18N) === true) {
    field = field.set(_i18n2.I18N, _i18n2.I18N_FIELD.TRANSLATE);
  } else if (field.get(_i18n2.I18N) === false || !field.has(_i18n2.I18N)) {
    field = field.set(_i18n2.I18N, _i18n2.I18N_FIELD.NONE);
  }

  return field;
}

function setI18nDefaults(defaultI18n, collectionOrFile) {
  if (defaultI18n && collectionOrFile.has(_i18n2.I18N)) {
    const collectionOrFileI18n = collectionOrFile.get(_i18n2.I18N);

    if (collectionOrFileI18n === true) {
      collectionOrFile = collectionOrFile.set(_i18n2.I18N, defaultI18n);
    } else if (collectionOrFileI18n === false) {
      collectionOrFile = collectionOrFile.delete(_i18n2.I18N);
    } else {
      const locales = collectionOrFileI18n.get('locales', defaultI18n.get('locales'));
      const defaultLocale = collectionOrFileI18n.get('default_locale', collectionOrFileI18n.has('locales') ? locales.first() : defaultI18n.get('default_locale'));
      collectionOrFile = collectionOrFile.set(_i18n2.I18N, defaultI18n.merge(collectionOrFileI18n));
      collectionOrFile = collectionOrFile.setIn([_i18n2.I18N, 'locales'], locales);
      collectionOrFile = collectionOrFile.setIn([_i18n2.I18N, 'default_locale'], defaultLocale);
      throwOnMissingDefaultLocale(collectionOrFile.get(_i18n2.I18N));
    }

    if (collectionOrFileI18n !== false) {
      // set default values for i18n fields
      if (collectionOrFile.has('fields')) {
        collectionOrFile = collectionOrFile.set('fields', (0, _collections.traverseFields)(collectionOrFile.get('fields'), setI18nField));
      }
    }
  } else {
    collectionOrFile = collectionOrFile.delete(_i18n2.I18N);

    if (collectionOrFile.has('fields')) {
      collectionOrFile = collectionOrFile.set('fields', (0, _collections.traverseFields)(collectionOrFile.get('fields'), field => field.delete(_i18n2.I18N)));
    }
  }

  return collectionOrFile;
}

function throwOnInvalidFileCollectionStructure(i18n) {
  if (i18n && i18n.get('structure') !== _i18n2.I18N_STRUCTURE.SINGLE_FILE) {
    throw new Error(`i18n configuration for files collections is limited to ${_i18n2.I18N_STRUCTURE.SINGLE_FILE} structure`);
  }
}

function throwOnMissingDefaultLocale(i18n) {
  if (i18n && !i18n.get('locales').includes(i18n.get('default_locale'))) {
    throw new Error(`i18n locales '${i18n.get('locales').join(', ')}' are missing the default locale ${i18n.get('default_locale')}`);
  }
}

function setViewPatternsDefaults(key, collection) {
  if (!collection.has(key)) {
    collection = collection.set(key, (0, _immutable.fromJS)([]));
  } else {
    collection = collection.set(key, collection.get(key).map(v => v.set('id', `${v.get('field')}__${v.get('pattern')}`)));
  }

  return collection;
}

const defaults = {
  publish_mode: _publishModes.SIMPLE
};

function hasIntegration(config, collection) {
  const integrations = (0, _integrations.getIntegrations)(config);
  const integration = (0, _integrations.selectIntegration)(integrations, collection.get('name'), 'listEntries');
  return !!integration;
}

function normalizeConfig(config) {
  const {
    collections = []
  } = config;
  const normalizedCollections = collections.map(collection => {
    const {
      fields,
      files
    } = collection;
    let normalizedCollection = collection;

    if (fields) {
      const normalizedFields = traverseFieldsJS(fields, setSnakeCaseConfig);
      normalizedCollection = _objectSpread(_objectSpread({}, normalizedCollection), {}, {
        fields: normalizedFields
      });
    }

    if (files) {
      const normalizedFiles = files.map(file => {
        const normalizedFileFields = traverseFieldsJS(file.fields, setSnakeCaseConfig);
        return _objectSpread(_objectSpread({}, file), {}, {
          fields: normalizedFileFields
        });
      });
      normalizedCollection = _objectSpread(_objectSpread({}, normalizedCollection), {}, {
        files: normalizedFiles
      });
    }

    if (normalizedCollection.sortableFields) {
      const {
        sortableFields
      } = normalizedCollection,
            rest = _objectWithoutProperties(normalizedCollection, ["sortableFields"]);

      normalizedCollection = _objectSpread(_objectSpread({}, rest), {}, {
        sortable_fields: sortableFields
      });
      console.warn(`Collection ${collection.name} is using a deprecated configuration 'sortableFields'. Please use 'sortable_fields'`);
    }

    return normalizedCollection;
  });
  return _objectSpread(_objectSpread({}, config), {}, {
    collections: normalizedCollections
  });
}

function applyDefaults(config) {
  return (0, _immutable.Map)(defaults).mergeDeep(config).withMutations(map => {
    var _i18n;

    // Use `site_url` as default `display_url`.
    if (!map.get('display_url') && map.get('site_url')) {
      map.set('display_url', map.get('site_url'));
    } // Use media_folder as default public_folder.


    const defaultPublicFolder = `/${(0, _trimStart2.default)(map.get('media_folder'), '/')}`;

    if (!map.has('public_folder')) {
      map.set('public_folder', defaultPublicFolder);
    } // default values for the slug config


    if (!map.getIn(['slug', 'encoding'])) {
      map.setIn(['slug', 'encoding'], 'unicode');
    }

    if (!map.getIn(['slug', 'clean_accents'])) {
      map.setIn(['slug', 'clean_accents'], false);
    }

    if (!map.getIn(['slug', 'sanitize_replacement'])) {
      map.setIn(['slug', 'sanitize_replacement'], '-');
    }

    let i18n = config.get(_i18n2.I18N);
    i18n = (_i18n = i18n) === null || _i18n === void 0 ? void 0 : _i18n.set('default_locale', i18n.get('default_locale', i18n.get('locales').first()));
    throwOnMissingDefaultLocale(i18n); // Strip leading slash from collection folders and files

    map.set('collections', map.get('collections').map(collection => {
      if (!collection.has('publish')) {
        collection = collection.set('publish', true);
      }

      collection = setI18nDefaults(i18n, collection);
      const folder = collection.get('folder');

      if (folder) {
        if (collection.has('path') && !collection.has('media_folder')) {
          // default value for media folder when using the path config
          collection = collection.set('media_folder', '');
        }

        collection = setDefaultPublicFolder(collection);
        collection = collection.set('fields', (0, _collections.traverseFields)(collection.get('fields'), setDefaultPublicFolder));
        collection = collection.set('folder', (0, _trim2.default)(folder, '/'));

        if (collection.has('meta')) {
          const fields = collection.get('fields');
          const metaFields = [];
          collection.get('meta').forEach((value, key) => {
            const field = value.withMutations(map => {
              map.set('name', key);
              map.set('meta', true);
              map.set('required', true);
            });
            metaFields.push(field);
          });
          collection = collection.set('fields', (0, _immutable.fromJS)([]).concat(metaFields, fields));
        } else {
          collection = collection.set('meta', (0, _immutable.Map)());
        }
      }

      const files = collection.get('files');

      if (files) {
        const collectionI18n = collection.get(_i18n2.I18N);
        throwOnInvalidFileCollectionStructure(collectionI18n);
        collection = collection.delete('nested');
        collection = collection.delete('meta');
        collection = collection.set('files', files.map(file => {
          file = file.set('file', (0, _trimStart2.default)(file.get('file'), '/'));
          file = setDefaultPublicFolder(file);
          file = file.set('fields', (0, _collections.traverseFields)(file.get('fields'), setDefaultPublicFolder));
          file = setI18nDefaults(collectionI18n, file);
          throwOnInvalidFileCollectionStructure(file.get(_i18n2.I18N));
          return file;
        }));
      }

      if (!collection.has('sortable_fields')) {
        const backend = (0, _backend.resolveBackend)(config);
        const defaultSortable = (0, _collections.selectDefaultSortableFields)(collection, backend, hasIntegration(map, collection));
        collection = collection.set('sortable_fields', (0, _immutable.fromJS)(defaultSortable));
      }

      collection = setViewPatternsDefaults('view_filters', collection);
      collection = setViewPatternsDefaults('view_groups', collection);

      if (map.hasIn(['editor', 'preview']) && !collection.has('editor')) {
        collection = collection.setIn(['editor', 'preview'], map.getIn(['editor', 'preview']));
      }

      return collection;
    }));
  });
}

function parseConfig(data) {
  const config = _yaml.default.parse(data, {
    maxAliasCount: -1,
    prettyErrors: true,
    merge: true
  });

  if (typeof CMS_ENV === 'string' && config[CMS_ENV]) {
    Object.keys(config[CMS_ENV]).forEach(key => {
      config[key] = config[CMS_ENV][key];
    });
  }

  return config;
}

async function getConfigYaml(file, hasManualConfig) {
  const response = await fetch(file, {
    credentials: 'same-origin'
  }).catch(err => err);

  if (response instanceof Error || response.status !== 200) {
    if (hasManualConfig) return parseConfig('');
    throw new Error(`Failed to load config.yml (${response.status || response})`);
  }

  const contentType = response.headers.get('Content-Type') || 'Not-Found';
  const isYaml = contentType.indexOf('yaml') !== -1;

  if (!isYaml) {
    console.log(`Response for ${file} was not yaml. (Content-Type: ${contentType})`);
    if (hasManualConfig) return parseConfig('');
  }

  return parseConfig(await response.text());
}

function configLoaded(config) {
  return {
    type: CONFIG_SUCCESS,
    payload: config
  };
}

function configLoading() {
  return {
    type: CONFIG_REQUEST
  };
}

function configFailed(err) {
  return {
    type: CONFIG_FAILURE,
    error: 'Error loading config',
    payload: err
  };
}

async function detectProxyServer(localBackend) {
  const allowedHosts = ['localhost', '127.0.0.1', ...((localBackend === null || localBackend === void 0 ? void 0 : localBackend.allowed_hosts) || [])];

  if (allowedHosts.includes(location.hostname)) {
    let proxyUrl;
    const defaultUrl = 'http://localhost:8081/api/v1';

    if (localBackend === true) {
      proxyUrl = defaultUrl;
    } else if ((0, _isPlainObject2.default)(localBackend)) {
      proxyUrl = localBackend.url || defaultUrl.replace('localhost', location.hostname);
    }

    try {
      console.log(`Looking for Netlify CMS Proxy Server at '${proxyUrl}'`);
      const {
        repo,
        publish_modes,
        type
      } = await fetch(`${proxyUrl}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          action: 'info'
        })
      }).then(res => res.json());

      if (typeof repo === 'string' && Array.isArray(publish_modes) && typeof type === 'string') {
        console.log(`Detected Netlify CMS Proxy Server at '${proxyUrl}' with repo: '${repo}'`);
        return {
          proxyUrl,
          publish_modes,
          type
        };
      }
    } catch {
      console.log(`Netlify CMS Proxy Server not detected at '${proxyUrl}'`);
    }
  }

  return {};
}

function getPublishMode(config, publishModes, backendType) {
  if (config.publish_mode && publishModes && !publishModes.includes(config.publish_mode)) {
    const newPublishMode = publishModes[0];
    console.log(`'${config.publish_mode}' is not supported by '${backendType}' backend, switching to '${newPublishMode}'`);
    return newPublishMode;
  }

  return config.publish_mode;
}

async function handleLocalBackend(config) {
  if (!config.local_backend) {
    return config;
  }

  const {
    proxyUrl,
    publish_modes: publishModes,
    type: backendType
  } = await detectProxyServer(config.local_backend);

  if (!proxyUrl) {
    return config;
  }

  const publishMode = getPublishMode(config, publishModes, backendType);
  return _objectSpread(_objectSpread(_objectSpread({}, config), publishMode && {
    publish_mode: publishMode
  }), {}, {
    backend: _objectSpread(_objectSpread({}, config.backend), {}, {
      name: 'proxy',
      proxy_url: proxyUrl
    })
  });
}

function loadConfig(manualConfig = {}, onLoad) {
  if (window.CMS_CONFIG) {
    return configLoaded((0, _immutable.fromJS)(window.CMS_CONFIG));
  }

  return async dispatch => {
    dispatch(configLoading());

    try {
      const configUrl = getConfigUrl();
      const hasManualConfig = !(0, _isEmpty2.default)(manualConfig);
      const configYaml = manualConfig.load_config_file === false ? {} : await getConfigYaml(configUrl, hasManualConfig); // Merge manual config into the config.yml one

      const mergedConfig = (0, _deepmerge.default)(configYaml, manualConfig);
      (0, _configSchema.validateConfig)(mergedConfig);
      const withLocalBackend = await handleLocalBackend(mergedConfig);
      const normalizedConfig = normalizeConfig(withLocalBackend);
      const config = applyDefaults((0, _immutable.fromJS)(normalizedConfig));
      dispatch(configLoaded(config));

      if (typeof onLoad === 'function') {
        onLoad();
      }
    } catch (err) {
      dispatch(configFailed(err));
      throw err;
    }
  };
}